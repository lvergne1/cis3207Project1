The program submitted is a discrete event simulation modeling a single processor driven system.  It should be noted that in such a system, only a single event may be processed at a time.  As such, the program, which uses several components at a time (that is, a disk and the processor might have events which occur simultaneously) must distinguish both between the relative and absolute occurrence of these events.
        The term relative occurrence of events refers to the fact that two events may occur simultaneously.  In such a case, a distinction must be made as to which event happened “first.”  In this simulation, this is determined by one main feature: first occurence.  If two events occur at a single time, whichever occurred first is processed first.  For example, suppose events 1 and 2 occur at time 10.  Although in the log, both occurred at time 10, in reality one occured before the other.  As such, the first event to occur is processed first.  
        The program is based on two queues, both of which are identical but for the push method.   The first is the server queue, a FIFO structure which represents the processor queue, and the queue of both disks. The second is the event queue which drives the fundamental behavior of the program. Both primary data structures use a linked list.
        In the case of the server queues (processor and disks one and two) a FIFO linked list is used.  The list keeps track of the first and last element.  As new elements were added, the last element (if present) was used to attach the new element. If no last element exists,  there is no first element, and as such,  a new list is being created, and so the element was added as the first element.
        In this list, it was only possible to remove the first element in the list (via the pop method). In such a case, the pop method obtains and returns the first event from the list, and then proceeds to free the memory associated with the node containing the first event.  It is then the responsibility of the user to deallocate the memory associated with the event.
        Upon completion, all four queues are destroyed: CPU, disk 1, disk 2, and the event queue. All of these are disposed of by identical means.  The pop method is called which returns the first item in the list  Once returned, the event is obtained and subsequently freed, and then the node containing the event is also freed.  This process continues until the list is empty.  Once empty, all memory associated with the list is freed.
        A linked list was chosen for two reasons.  First, with the addition of the size feature, elements could be added and removed instantly (that is, with no associated data operations).  Since the event queue is a priority queue, this could contain a drawback: a loss of time while the list is iterated to insert an event. However, despite this drawback I chose this since when using the server queues, events are only added to the end of the list, and as such, require no iterations.  In the case of a priority queue (as used by the event queue) iterations must necessarily take place.  However, given the long run time of the simulation, and the fact that by comparison  a few iterations of the list could be possible at a particular instance during addition of new elements, a linked list seemed appropriate.  
        Now since a queue and a priority queue are fundamentally the same besides the way in which elements are added, a linked list in a typedef struct was used.  To add elements to the queue, the program uses two methods: push and pushByLowestTime.  The push method is relatively simple by comparison: elements are added as the list element, and if no last element exists, they are also added to the first element. If using pushByLowestTime, elements added to the list iterate the list sequentially and once their place is found (their time is lower than the time of the found object) they are inserted into the list.  
        Events are removed from the list by the pop method, which takes the first element from the list, returns the event, and frees the associated node.  It is the responsibility of the user, at this point, to free the event, however, unless the event is the final event, destruction and clean up are implemented upon destruction. The destroyQueue method pops and frees elements from the list until the list is empty.
        A linked list seemed the obvious choice for the server queues.  Elements are only added to the last element, and only retrieved from the first, and as such insertion and removal from the list occur in constant time.  However, the event queue was not at first obvious.  Since in general, insertion could occur at the last element, the an insertion could occur in O(n) time.  However, since in events occur relatively close to the head, we can reduce this to constant time, bounded above by the largest max constant (for example, jobArrivalMax).  Since the fundamental difference between a queue and a priority queue is in the method of insertion (or could be in this case), a linked list was used.  
        The main method in eventsim.c calls runSimulation() method in simulation.c, which is responsible for initializing all values associated with the simulation.  I chose this, since in such a case, one could call runSimulation in a for loop, and as such (with little modification to the program) could obtain better statistics.  In the current context, such statistics weren’t required, however, in building the program, the statistics (particularly how they changed from run to run) were useful in determining values for constants.  
        There were several aspects of the code to be tested: the queue data structures, the reliability of the statistics, and the random number generator.  The queue data structure’s push pushBySize and pop() methods were vital, and all interconnected.  A small driver was used (queue_test) in order to test these.  The program first created an array of Events, and these events were then pushed and popped from the list.  After each iteration, the size of the list and each element in the list were printed to the screen. 
        The random number generator was comparatively easier to test.  Since arc4random_uniform was used for the random number generation, there was comparatively little here to test.  This function automatically chooses a seed and so there was little here to test.  In this case the lrnd(min, max) function was called in a for loop to ensure a range of values, and that the sequence was different each time.
        The statistics were slightly more difficult to set up and test.  First, the functions to track statistics were all placed in the statistics.c file.  Every time something is added to one of the server queues, the change is tracked in the statistics file, and if the length is greater than the old maximum, it is set as the new maximum. In order to track the response time, a variable was used to hold the value that would be added if the event finished.  Once the server finishes, it calls the *server*finished method, the counter of finished jobs is incremented, and the pending server response time variable is added to the server response time variable.  At the end of the program, this is divided by the total number of jobs.